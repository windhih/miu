// Определяем параметры модели    
var sourceLocation = ee.Geometry.Point([37.8833, 59.1167]); // Координаты источника выброса (Череповец)
var U = ee.Number(2); // Скорость ветра
var zh = ee.Number(50); // Высота источника выброса
var z = ee.Number(2); // Уровень высоты для расчета концентрации
// Константы для расчета SygmaY для устойчивочти атмосферы F
var c = ee.Number(4.1667);
var d = ee.Number(0.36191);

// Определим временной интервал для данных
var startDate = '2023-07-01';
var endDate = '2023-07-07';

// Определяем разрешение
var Maschtab = 1000; // Примерное значение масштаба в метрах

// Создаем сетку координат вокруг Череповца
var grid = ee.Image.pixelLonLat().rename(['lon', 'lat']);

// Преобразуем координаты источника в изображение для корректного вычитания
var sourceLat = ee.Image.constant(sourceLocation.coordinates().get(1));

// Загружаем данные Sentinel-5P
var sentinel5P = ee.ImageCollection('COPERNICUS/S5P/OFFL/L3_CH4')
  .filterDate(startDate, endDate) // Пример диапазона дат для получения данных
  .select('CH4_column_volume_mixing_ratio_dry_air')
  .map(function(image) {
    // Возможно, добавить фильтрацию по качеству данных или другим критериям
    return image.set('system:time_start', image.get('system:time_start'));
  });

// Если нужно одно изображение, используйте .first(), если среднее - используйте reduce:
//var ch4Image = sentinel5P.first().rename('ch4');
// Или для среднего по периоду:
var ch4Average = sentinel5P.reduce(ee.Reducer.mean()).rename('ch4');
// Теперь можно использовать ch4Image или ch4Average в дальнейшем анализе

// Преобразование ppb в моль/м³ (на уровне моря при стандартных условиях)
var molarMassCH4 = 16.04; // г/моль - молекулярная масса метана
var R = 8.314462618; // Дж/(моль*К) - универсальная газовая постоянная
var T = 298.15; // Кельвин, стандартная температура
var P = 101325; // Паскаль, стандартное атмосферное давление

// Поскольку Sentinel-5P дает данные в ppb, а нам нужно в моль/м³:
var convertPPBToMolPerM3 = function(image) {
  return image.divide(1e9).multiply(P / (R * T)); // из ppb в моль/м³
};

var ch4MolPerM3 = convertPPBToMolPerM3(ch4Average);

// Перевод из моль/м³ в г/м³
var ch4GPerM3 = ch4MolPerM3.multiply(molarMassCH4).rename('ch4_concentration_g_per_m3');

// Функция поворота изоображения расчетного поля концентраций
// по умолчаню изоображение рассчетного поля концентраций формируется
// для западного направления ветра (угол поворота 0 градусов)
// чтобы поле концентрации соответствовало текущему направлению ветра
// его необходимо повернуть на угол angle вокруг центра изоображения origin 
// image - это поворачиваемое изоображени поля концентраций. opt_proj- проекция не обязательно указывать
var rotateImage = function(image, origin, angle, opt_proj) {
  var proj = opt_proj || 'EPSG:3857';
  
  proj = ee.Projection(proj);
  angle = ee.Number(angle);

  var coords = ee.Image.pixelCoordinates(proj);
  origin = ee.Geometry(origin).transform(proj).coordinates();
  var coordsRelative = coords.subtract(ee.Image.constant(origin));

  var bands = coords.bandNames();
  var rotation = ee.Image(ee.Array([ [angle.cos(), angle.sin().multiply(-1)], [angle.sin(), angle.cos()] ]));
  var coordsRotated = rotation.matrixMultiply(coordsRelative.toArray().arrayRepeat(1, 1)).arrayTranspose().arrayProject([1]).arrayFlatten([bands]);
  
  return image.displace(coordsRotated.subtract(coordsRelative));
};

// Функция для преобразования строки направления в угол в радианах
function windDirectionToAngle(direction) {
  // Направления ветра и соответствующие углы в радианах
  var directions = {
    'N': Math.PI / 2,          // Север
    'NE': 3 * Math.PI / 4,     // Северо-восток 
    'E': Math.PI,              // Восток 
    'SE': 5 * Math.PI / 4,     // Юго-восток  
    'S': 3 * Math.PI/ 2,       // Юг
    'SW': 7 * Math.PI / 4,     // Юго-запад  
    'W':  0,                   // Запад  
    'NW': Math.PI / 4,         // Северо-запад  
  };
  // Проверка на null или недопустимое направление
  if (!direction || !directions.hasOwnProperty(direction.toUpperCase())) {
    print('недопустимое напрв=авление ветра');
    return null; // Возвращаем null для недопустимых направлений
  }
  // Возвращаем угол в радианах для указанного направления
  return ee.Number(directions[direction.toUpperCase()]);
}

// Вводим направление ветра для цепочки расчетных дней
var windDirection = 'SW'; // Направление ветра (например, "NW" — северо-запад)
var angleInRadians = windDirectionToAngle(windDirection);

// Вспомогательная функция для получения SigmaZ
function getsigmaZ(lonDiff) {
  // Convert lonDiff from degrees to kilometers
  var earthRadiusKm = 6371; // Earth's mean radius in kilometers
  var latRadians = ee.Number(59.1167).multiply(Math.PI / 180); // Convert latitude to radians
  var cosLat = ee.Number(Math.cos(latRadians.getInfo())); // Get cosine of latitude
  var lonDiffKm = lonDiff.multiply(Math.PI / 180).multiply(earthRadiusKm).multiply(cosLat);
//  lonDiffKm.evaluate(function(value) {
//  print('lonDiffKm:', value);
//});
  var a, b;
  if (lonDiffKm.lte(0.20)) { a = ee.Number(15.209); b = ee.Number(0.81558); }
  else if (lonDiffKm.lte(0.70 )) { a = ee.Number(14.457); b = ee.Number(0.78407); }
  else if (lonDiffKm.lte(1.00 )) { a = ee.Number(13.953); b = ee.Number(0.68465); }
  else if (lonDiffKm.lte(2.00 )) { a = ee.Number(13.953); b = ee.Number(0.63227); }
  else if (lonDiffKm.lte(3.00 )) { a = ee.Number(14.823); b = ee.Number(0.54503); }
  else if (lonDiffKm.lte(7.00 )) { a = ee.Number(16.187); b = ee.Number(0.46490); }
  else if (lonDiffKm.lte(15.00 )) { a = ee.Number(17.836); b = ee.Number(0.41507); }
  else if (lonDiffKm.lte(30.00 )) { a = ee.Number(22.651); b = ee.Number(0.32681); }
  else if (lonDiffKm.lqe(60.00 )) { a = ee.Number(27.074); b = ee.Number(0.27436); }
  else { a = ee.Number(34.219); b = ee.Number(0.21716); }
// print('a   b' , a, b, lonDiffKm);
  var sigmaZ = ee.Image.constant(a).multiply(lonDiffKm.pow(b)); // Использование ee.Image.pow()
//  print('sigmaZ' , ee.Number(sigmaZ));
  return sigmaZ;
}


// Функция для расчета концентрации с изменяющимся Q
var calculateConcentration = function(Q) {
  var lonDiff = grid.select('lon').subtract(37.8833).max(0); // max(0)- исключаем из расчета отрицательные координаты, значение концентрации делаем 0
  if (lonDiff !== null) {
  var sigmaZ = getsigmaZ(lonDiff);
} else {
  print('lonDiff is null');
}
// Если вам нужно увидеть значения для всей области, можно вывести статистику
//lonDiff.reduceRegion({
//  reducer: ee.Reducer.minMax(),
//  geometry: sourceLocation.buffer(10000), // или любая другая область интереса
//  scale: Maschtab
//}).evaluate(function(stats) {
//  print('Минимальное и максимальное значение lonDiff:', stats);
//});

  var earthRadiusKm = 6371; // Earth's mean radius in kilometers
  var latRadians = ee.Number(59.1167).multiply(Math.PI / 180); // Convert latitude to radians
  var cosLat = ee.Number(Math.cos(latRadians.getInfo())); // Get cosine of latitude
  var lonDiffKm = lonDiff.multiply(Math.PI / 180).multiply(earthRadiusKm).multiply(cosLat);

// Calculate sigmaY using expression
var sigmaY1 = lonDiffKm.expression(
    '(465.11628 * abs(lon) * tan(0.017453293 * (c - d * log(abs(lon) + 0.00001))))/10', 
    {
      'lon': lonDiffKm, // Use 'lon' as the name for the lonDiff band in the expression
      'c': c,
      'd': d
    }
);

// print('Debug: sigmaZ', sigmaZ);
  return grid.expression(
     'Calc = 1000 * Q / (2 * PI * U * sigmaY1 * sigmaZ) * exp(-(latDiff * latDiff) / (2 * sigmaY1 * sigmaY1)) * ' + 
    '(exp(-((z - zh) * (z - zh)) / (2 * sigmaZ * sigmaZ)) + exp(-((z + zh) * (z + zh)) / (2 * sigmaZ * sigmaZ)))', 
    {
      'Q': Q,
      'U': U,
      'zh': zh,
      'z': z,
      'latDiff': grid.select('lat').subtract(sourceLat).multiply(1000),
      'sigmaZ' : sigmaZ,
      'sigmaY1' : sigmaY1,
      'PI': Math.PI,
      'c': c,
      'd': d
    }
  ).rename('concentration').clip(sourceLocation.buffer(30000)); // назначаем буфер вокруг источника выброса 30 километров
};


// Создаем список значений Q
var Qvalues = ee.List.sequence(0.001, 0.1, 0.005); 

// Функция для вычисления суммы квадратов разностей
var sumOfSquareDifferences = function(calculated, observed) {
  return calculated.subtract(observed).pow(2).reduceRegion({
    reducer: ee.Reducer.sum(),
    geometry: sourceLocation.buffer(30000),
    scale: Maschtab // Используем переменную Maschtab для масштаба
  }).get('concentration'); // Используем ключ, соответствующий названию полосы
};

// Проходим по каждому значению Q и сравниваем
var results = ee.List(Qvalues).map(function(Q) {
  var Qnum = ee.Number(Q);
  // считаем концентрации для направления запад
  var calculatedConcNo = calculateConcentration(Qnum);
  // поворачиваем расчетное поле концентраций в соответствие с направлением ветра
  var calculatedConc = rotateImage(calculatedConcNo, sourceLocation, angleInRadians);
  if (calculatedConc !== null) {
    var ssd = sumOfSquareDifferences(calculatedConc, ch4GPerM3);
    if (ssd !== null) {
      return ee.Dictionary({
        'Q': Qnum,
        'SSD': ee.Number(ssd),
      });
    }
  }
  return null; // Return null if any step fails
}).removeAll([null]);


// Преобразуем результаты в таблицу
var resultsTable = ee.FeatureCollection(results.map(function(dict) {
  dict = ee.Dictionary(dict);
  if (dict.size().gt(0)) {
    return ee.Feature(null, dict);
  } else {
    return null;
  }
}).filter(ee.Filter.notNull(['Q', 'SSD'])));

// Выводим результаты
print('Таблица результатов расчетов СКО:', resultsTable);
// Отображаем лучшую модель на карте
var bestQ = resultsTable.sort('SSD').first().get('Q');
var bestSSD = resultsTable.sort('SSD').first().get('SSD');
var bestModelNo = calculateConcentration(ee.Number(bestQ));
//------------------------------------поворот изоображения
// Вызов функции rotateImage
var bestModel = rotateImage(bestModelNo, sourceLocation, angleInRadians);
print('Наименьшее СКО ', bestSSD,' для модели с Q=', bestQ, 'кг/с');


// ---------------------------------------
// Выберем значение Q оптимальное
var concentrationMap = bestModel;

// Определите точку, в которой хотите получить расчетную концентрацию
var pointOfInterest = ee.Geometry.Point([37.91, 59.12]); // Пример координаты

// Получение расчетной концентрации в точке
var concentrationAtPoint = concentrationMap.reduceRegion({
  reducer: ee.Reducer.first(),
  geometry: pointOfInterest,
  scale: Maschtab // Используем переменную Maschtab для масштаба
}).get('concentration');

// Вывод расчетной концентрации в точке
print('Расчетная концентрация в точке (г/м3):', concentrationAtPoint);

// Определите точку, в которой хотите получить концентрацию по данным спутника
var pointOfInterest = ee.Geometry.Point([37.91, 59.12]); // Пример координаты


// Получение концентрации ch4 в точке из данных Sentinel-5P в г/м3
var ch4atPoint = ch4GPerM3.reduceRegion({
  reducer: ee.Reducer.first(),
  geometry: pointOfInterest,
  scale: Maschtab // Используем переменную Maschtab для масштаба
}).get('ch4_concentration_g_per_m3');

// Вывод концентрации CH4 в точке
print(' Концентрация CH4 в точке по данным Sentinel-5P (г/м3):', ch4atPoint);

Map.setCenter(37.8833, 59.1167, 10);
Map.addLayer(bestModel, {min: 0, 
                                   max: 0.05, 
                                   palette: ['blue', 'green', 'yellow', 'red']}, 'Поле концентрации метана для лучшей модели (г/м3)');
Map.addLayer(ch4GPerM3, {min: 0, max: 0.001, palette: ['black', 'blue', 'cyan', 'green', 'yellow', 'red']}, 'Концентрация метана по данным Landsat-5P (г/м3)');
Map.addLayer(sourceLocation, {color: 'black'}, 'Источник выброса');
Map.addLayer(pointOfInterest, {color: 'red'}, 'Контрольная точка определения концентрации');

// Добавим легенду
var legend = ui.Panel({
  style: {
    position: 'bottom-left',
    padding: '8px 15px'
  }
});

var legendTitle = ui.Label({
  value: 'Концентрация метана,  (г/м3)',
  style: {fontWeight: 'bold', fontSize: '18px', margin: '0 0 4px 0'}
});
legend.add(legendTitle);

var makeRow = function(color, name) {
  var colorBox = ui.Label({
    style: {
      backgroundColor: color,
      padding: '8px',
      margin: '0 0 4px 0'
    }
  });

  var description = ui.Label({
    value: name,
    style: {margin: '0 0 4px 6px'}
  });

  return ui.Panel({
    widgets: [colorBox, description],
    layout: ui.Panel.Layout.Flow('horizontal')
  });
};

legend.add(makeRow('blue', '< 0.0029'));
legend.add(makeRow('cyan', '0.0029 - 0.0030'));
legend.add(makeRow('green', '0.0030 - 0.00306'));
legend.add(makeRow('yellow', '0.00306 - 0.0031'));
legend.add(makeRow('red', '> 0.0032'));

Map.add(legend);
// РАСЧЕТ НЕКАНЦЕРОГЕННОГО РИСКА ЗДОРОВЬЮ
// Референсная концентрация для метана
var RfC = 50 / 1000; // г/м³

// Расчет HQ
var HQ = ch4GPerM3.divide(RfC);

// Классификация уровней риска
var riskLevels = HQ
  .where(HQ.gt(3), 4) // Высокий уровень риска (HQ > 3)
  .where(HQ.gte(1.1).and(HQ.lte(3)), 3) // Настораживающий уровень риска (1.1 <= HQ <= 3)
  .where(HQ.gte(0.1).and(HQ.lt(1.1)), 2) // Допустимый уровень риска (0.1 <= HQ < 1.1)
  .where(HQ.lt(0.1), 1); // Минимальный уровень риска (HQ < 0.1)

// Палитра для визуализации уровней риска
var riskPalette = {
  min: 1,
  max: 4,
  palette: ['green', 'yellow', 'orange', 'red'] // Цвета для уровней риска
};

// Визуализация карты
//Map.centerObject(ch4GPerM3, 10); // Центрирование карты на изображении
Map.addLayer(riskLevels, riskPalette, 'Уровни риска');

// Добавление легенды
var legend = ui.Panel({
  style: {
    position: 'bottom-right',
    padding: '8px 15px'
  }
});

var legendTitle = ui.Label({
  value: 'Уровни риска',
  style: {
    fontWeight: 'bold',
    fontSize: '18px',
    margin: '0 0 4px 0',
    padding: '0'
  }
});

legend.add(legendTitle);

var levels = [
  {color: 'green', label: 'Минимальный < 0.000001 (HQ < 0.1)'},
  {color: 'yellow', label: 'Допустимый 0.000011-0.00011 (0.1 <= HQ < 1.1)'},
  {color: 'orange', label: 'Настораживающий 0.00011-0.001 (1.1 <= HQ <= 3)'},
  {color: 'red', label: 'Высокий > 0.001 (HQ > 3)'}
];

levels.forEach(function(level) {
  var colorBox = ui.Label({
    style: {
      backgroundColor: level.color,
      padding: '8px',
      margin: '0 0 4px 0'
    }
  });

  var description = ui.Label({
    value: level.label,
    style: {margin: '0 0 0 6px'}
  });

  legend.add(ui.Panel([colorBox, description], ui.Panel.Layout.Flow('horizontal')));
});

Map.add(legend);